# 第二章

1.下面的预处理器编译指令是做什么用的？

```c++
#include <iostream>
```

这将导致在最终的编译之前，使用 iostream 文件的内容替换该编译指令。  

# 第三章

1．为什么 C++有多种整型？

有多种整型类型，可以根据特定需求选择最适合的类型。例如，可以使用 short 来存储空格，使用long 来确保存储容量，也可以寻找可提高特定计算的速度的类型。  

3．C++提供了什么措施来防止超出整型的范围？

C++没有提供自动防止超出整型限制的功能，可以使用头文件 climits 来确定限制情况。  

5．下面两条 C++语句是否等价？

```c++
char grade = 65;
char grade = 'A'
```

这两条语句并不真正等价，虽然对于某些系统来说，它们是等效的。最重要的是，只有在使用 ASCII码的系统上，第一条语句才将得分设置为字母 A，而第二条语句还可用于使用其他编码的系统。其次， 65是一个 int 常量，而‘A’是一个 char 常量。    

7．将 long 值赋给 float 变量会导致舍入误差，将 long 值赋给 double 变量呢？将 long long 值赋给 double变量呢？

这个问题的答案取决于这两个类型的长度。如果 long 为 4 个字节，则没有损失。因为最大的 long值将是 20 亿，即有 10 位数。由于 double 提供了至少 13 位有效数字，因而不需要进行任何舍入。long long类型可提供 19 位有效数字，超过了 double 保证的 13 位有效数字  

# 第四章

6．声明一个 char 的数组，并将其初始化为字符串“cheeseburger”

```c++
char lunch[13] = "cheeseburger";// number of characters + 1
或者
char lunch[] = "cheeseburger"; // let the compiler count elements
```

# 第五章

8．下面的语句是否有效？如果无效，原因是什么？如果有效，它将完成什么工作？  

```c++
int x = (1, 024);
```

下面的语句又如何呢？  

```c++
int y;
y = 1, 024;
```

当然，第一条语句是有效的。表达式 1， 024 由两个表达式组成—1 和 024，用逗号运算符连接。值为右侧表达式的值。这是 024，八进制为 20，因此该声明将值 20 赋给 X。第二条语句也是有效的然而，运算符优先级将导致它被判定成这样：

```
(y = 1),024;
```

也就是说，左侧表达式将 y 设置成 1，整个表达式的值（没有使用）为 024 或 20（八进制）。  

9．在查看输入方面， cin >>ch 同 cin.get(ch)和 ch=cin.get( )有什么不同？  

cin>> ch 将跳过空格、换行符和制表符，其他两种格式将读取这些字符。  

# 第七章

6．为什么不对类型为基本类型的函数参数使用 const 限定符？  

将 const 限定符用于指针，以防止指向的原始数据被修改。程序传递基本类型（如 int 或 double）时，它将按值传递，以便函数使用副本。这样，原始数据将得到保护。  

9．表达式*"pizza"的含义是什么？ "taco" [2]呢？  

由于 C++将“pizza”解释为其第一个元素的地址，因此使用*运算符将得到第一个元素的值，即字符p。由于 C++将“taco”解释为第一个元素的地址，因此它将“taco” [2]解释为第二个元素的值，即字符c。换句话来说，字符串常量的行为与数组名相同。  

13．假设函数 f1()和 f2()的原型如下：

```c++
void f1(applicant * a);
const char * f2(const applint * a1, const applicnat * a2);
```

请将 p1 和 p2 分别声明为指向 f1 和 f2 的指针；将 ap 声明为一个数组，它包含 5 个类型与 p1 相同的指针；将 pa 声明为一个指针，它指向的数组包含 10 个类型与 p2 相同的指针。使用 typedef 来帮助完成这项工作。  

```c++
void (*p1)(applicant *) = f1;
const char * (*p2)(const applint *, const applicnat * a2) = f2;
void (*ap)[5](applicant *);
const char * (*pa)[10](const applint *, const applicnat * a2);
    
```

```c++
typedef void (*p_f1)(applicant *);
p_f1 p1 = f1;
typedef const char * (*p_f2)(const applint *, const applicnat *);
p_f2 p2 = f2;
p_f1 ap[5];
p_f2 (*pa)[10];
```

