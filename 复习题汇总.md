# 第二章

1.下面的预处理器编译指令是做什么用的？

```c++
#include <iostream>
```

这将导致在最终的编译之前，使用 iostream 文件的内容替换该编译指令。  

# 第三章

1．为什么 C++有多种整型？

有多种整型类型，可以根据特定需求选择最适合的类型。例如，可以使用 short 来存储空格，使用long 来确保存储容量，也可以寻找可提高特定计算的速度的类型。  

3．C++提供了什么措施来防止超出整型的范围？

C++没有提供自动防止超出整型限制的功能，可以使用头文件 climits 来确定限制情况。  

5．下面两条 C++语句是否等价？

```c++
char grade = 65;
char grade = 'A'
```

这两条语句并不真正等价，虽然对于某些系统来说，它们是等效的。最重要的是，只有在使用 ASCII码的系统上，第一条语句才将得分设置为字母 A，而第二条语句还可用于使用其他编码的系统。其次， 65是一个 int 常量，而‘A’是一个 char 常量。    

7．将 long 值赋给 float 变量会导致舍入误差，将 long 值赋给 double 变量呢？将 long long 值赋给 double变量呢？

这个问题的答案取决于这两个类型的长度。如果 long 为 4 个字节，则没有损失。因为最大的 long值将是 20 亿，即有 10 位数。由于 double 提供了至少 13 位有效数字，因而不需要进行任何舍入。long long类型可提供 19 位有效数字，超过了 double 保证的 13 位有效数字  

# 第四章

6．声明一个 char 的数组，并将其初始化为字符串“cheeseburger”

```c++
char lunch[13] = "cheeseburger";// number of characters + 1
或者
char lunch[] = "cheeseburger"; // let the compiler count elements
```

# 第五章

8．下面的语句是否有效？如果无效，原因是什么？如果有效，它将完成什么工作？  

```c++
int x = (1, 024);
```

下面的语句又如何呢？  

```c++
int y;
y = 1, 024;
```

当然，第一条语句是有效的。表达式 1， 024 由两个表达式组成—1 和 024，用逗号运算符连接。值为右侧表达式的值。这是 024，八进制为 20，因此该声明将值 20 赋给 X。第二条语句也是有效的然而，运算符优先级将导致它被判定成这样：

```
(y = 1),024;
```

也就是说，左侧表达式将 y 设置成 1，整个表达式的值（没有使用）为 024 或 20（八进制）。  

9．在查看输入方面， cin >>ch 同 cin.get(ch)和 ch=cin.get( )有什么不同？  

cin>> ch 将跳过空格、换行符和制表符，其他两种格式将读取这些字符。  

# 第七章

6．为什么不对类型为基本类型的函数参数使用 const 限定符？  

将 const 限定符用于指针，以防止指向的原始数据被修改。程序传递基本类型（如 int 或 double）时，它将按值传递，以便函数使用副本。这样，原始数据将得到保护。  

9．表达式*"pizza"的含义是什么？ "taco" [2]呢？  

由于 C++将“pizza”解释为其第一个元素的地址，因此使用*运算符将得到第一个元素的值，即字符p。由于 C++将“taco”解释为第一个元素的地址，因此它将“taco” [2]解释为第二个元素的值，即字符c。换句话来说，字符串常量的行为与数组名相同。  

13．假设函数 f1()和 f2()的原型如下：

```c++
void f1(applicant * a);
const char * f2(const applint * a1, const applicnat * a2);
```

请将 p1 和 p2 分别声明为指向 f1 和 f2 的指针；将 ap 声明为一个数组，它包含 5 个类型与 p1 相同的指针；将 pa 声明为一个指针，它指向的数组包含 10 个类型与 p2 相同的指针。使用 typedef 来帮助完成这项工作。  

```c++
void (*p1)(applicant *) = f1;
const char * (*p2)(const applint *, const applicnat * a2) = f2;
void (*ap[5])(applicant *);
const char * (*pa[10])(const applint *, const applicnat * a2);
    
```

```c++
typedef void (*p_f1)(applicant *);
p_f1 p1 = f1;
typedef const char * (*p_f2)(const applint *, const applicnat *);
p_f2 p2 = f2;
p_f1 ap[5];
p_f2 (*pa)[10];
```

# 第八章

1．哪种函数适合定义为内联函数？  

只有一行代码的小型、非递归函数适合作为内联函数，并且重复多次调用，调用时间和执行时间数量级差不多。

2.可以为指针赋默认值

7.编写返回两个参数中较大值的函数模板  

```c++
template<class T> 
T max(const T & a, const T & b){
    return a > b? a:b;
}
```

9． 在下述代码（假定这些代码是一个完整程序的一部分）中， v1、 v2、 v3、 v4 和 v5 分别是哪种类型？  

```c++
int g(int x);
f1oat m = 5.5f;
float & rm = m;
decltype(m) vl = m;
decltype(rm )v2 = m;
decltype((m))v3 = m;
decltype(g(100)) v4;
decltype(2.0*m) v5;
```

v1 的类型为 float， v2 的类型为 float &， v3 的类型为 float &， v4 的类型为 int， v5 的类型为double。字面值 2.0 的类型为 double，因此表达式 2.0 * m 的类型为 double。  

# 第九章

5．在一个文件中调用 average(3, 6)函数时，它返回两个 int 参数的 int 平均值，在同一个程序的另一个文件中调用时，它返回两个 int 参数的 double 平均值。应如何实现？  

可以在每个文件中包含单独的静态函数定义。或者每个文件都在未命名的名称空间中定义一个合适的 average( )函数。  

# 第十章

1．什么是类？  

类是用户定义的类型的定义。类声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员函数）。  

2．类如何实现抽象、封装和数据隐藏？  

类方法表示人们可以使用的公有接口对类对象执行的操作，这是抽象。类的数据成员可以是私有的（默认值），这意味着只能通过成员函数来访问这些数据，这是数据隐藏。实现的具体细节（如数据表示和方法的代码）都是隐藏的，这是封装。  

4．除了是函数之外，类函数成员与类数据成员之间的区别是什么？  

如果创建给定类的多个对象，则每个对象都有其自己的数据内存空间;但所有的对象都使用同一组成员函数（通常，方法是公有的，而数据是私有的，但这只是策略方面的问题，而不是对类的要求）  

8．什么是默认构造函数，拥有默认构造函数有何好处？  

默认构造函数是没有参数或所有参数都有默认值的构造函数。拥有默认构造函数后，可以声明对象，而不初始化它，即使已经定义了初始化构造函数。它还使得能够声明数组。  

10． this 和*this 是什么？  

this 指针是类方法可以使用的指针，它指向用于调用方法的对象。因此， this 是对象的地址， *this是对象本身。  